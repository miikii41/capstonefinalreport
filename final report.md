<!-- Template for PROJECT REPORT of CapstoneDesign 2024-2H, initially written by khyoo -->
<!-- 본 파일은 2024년도 컴공 졸업프로젝트의 <1차보고서> 작성을 위한 기본 양식입니다. -->
<!-- 아래에 "*"..."*" 표시는 italic체로 출력하기 위해서 사용한 것입니다. -->
<!-- "내용"에 해당하는 부분을 지우고, 여러분 과제의 내용을 작성해 주세요. -->

# Team-Info
| (1) 과제명 | *Fashion Seek : 체형 및 스타일에 맞는 코디 추천을 원하는 seeker에게 맞춤형 setter가  리뷰 사진 및 모델 사진을 분석하는 AI모델을 활용하여 최적의 아이템을 선별해 코디 조언을 해주는 어플*
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 21-반려코더스 |
| (3) 팀 구성원 | 김도윤 (2176045) : *UI 디자인 및 프론트엔드 및 AI* <br> 송민경 (2176189): *UI 디자인 및 프론트엔드 및 AI* <br> 황채현 (2176431): *백엔드* |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 한승우 / 블룸테크놀로지 / 부장 |
| (6) 과제 분류 | 산학과제 |
| (6) 과제 키워드 | 맞춤형 코디, Match R-CNN, nc loss model  |
| (7) 과제 내용 요약 | 저희 앱의 플로우는 다음과 같습니다. 각자의 체형 정보 및 스타일을 기입하여 회원가입을 진행합니다. 세터는, 자신의 포트폴리오를 채운 후, 자신에게 들어올 코디 요청을 기다립니다. 시커는, 자신이 코디를 함께 하고 싶은 옷과 장소, 함께 만나는 사람들을 입력하여 제안서를 보냅니다. 제안서를 받은 세터 중 2명의 세터가 제안을 수락하고 코디를 진행합니다. 코디를 진행할 때, 먼저 시중에 공개된 패션 데이터셋을 이용하여 Mask R-CNN 기반의 Match R-CNN 모델을 생성 및 학습을 진행합니다. 이후, 크롤링을 통해 수집한 데이터를 AI 모델로 분석한 뒤, 학습된 데이터셋과 동일한 형식으로 변환하여 분석할 계획입니다. 통계를 내는 방식을 이용하여, 가장 많이 매칭한 옷과 모델샷에서 함께 입은 옷을 분석한 DB를 구성하는 것을 목표로 하고 있습니다. 두번째로, seeker와 setter의 매칭 알고리즘을 구현합니다.이 알고리즘은 seeker와 비슷한 체형을 가진 setter를 매칭하는 역할을 합니다. 만약 동일한 체형 및 컴플렉스를 가진 setter가 없을 경우, 근접한 체형의 setter를 자동으로 매칭할 수 있는 알고리즘을 설계할 예정입니다. |

<br>

# Project-Summary
| 항목 | 내용 |
|:---  |---  |
| (1) 문제 정의 | 본 과제를 통하여 기존에 옷장 속에서 방치된 옷들을 전문가의 맞춤형 코디 제안을 통해 다시 활용함으로써, 새로운 의류 소비를 억제하여 폐의류 문제를 해결하고자 합니다. 그렇기에 저희의 Target Customer은 패션에 관심이 많은 20대입니다. 저희 어플의 사용자는 패션 조언을 구하는 ‘시커’와 조언을 제공하는 ‘세터’로 두 그룹으로 나뉩니다. 먼저, seeker의 경우 급변하는 패션 트렌드를 따라가기 어렵거나, 자신이 좋아하는 스타일을 찾는데에 어려움을 겪고 있습니다. 혹은, 충분한 옷을 가지고 있지만 그 옷들을 효과적으로 매칭하지 못하는 사람들입니다. 이들은 스타일링에 대한 욕구는 있지만, 어떻게 스타일링을 해야할지를 찾지 못해 어려움을 겪는 고객들입니다. 반면, setter는 자신의 취향과 전문성을 바탕으로 트렌디한 코디를 제안하고 싶어하지만, 타인의 옷장을 파악하는 데 시간이나 자원의 한계를 느끼는 패션 전문가들입니다. 또한, 경력이나 포트폴리오가 부족해 패션 업계에서 취업에 어려움을 겪고 있는 사람들 또한 setter로 활동할 수 있습니다.  |
| (2) 기존연구와의 비교 | 유사한 시스템으로는 “코콘”, “스타일봇”, “이옷”이 있습니다. <br> **1. 코콘** <br> '코콘'은 유료 구독을 통해 AI 스타일리스트를 활용할 수 있는 어플입니다. 사용자가 사진이나 신체 둘레 사이즈를 입력하면, AI를 활용하여 이미지 분석, 체형 분석, 퍼스널컬러 분석을 진행합니다. 실제 신체 사이즈를 입력했을 때, 사용자의 체형 분석 후 옷을 추천해주기 때문에 사용자는 자신의 체형에 대한 정보도 파악할 수 있다는 장점이 있습니다. 다만, AI 스타일리스트를 단독으로 사용했을 때, 현실감이 떨어지고 날씨와 장소를 함께 고려하기가 어렵다는 문제점이 있습니다. 또한, 키나 몸무게가 고려되지 않아 사용자가 실제로 입을 수 있는 옷인지를 파악할 수가 없습니다. 또한, 유료 구독이라는 점이 진입 장벽을 높게 할 수 있습니다. <br> **2. 스타일봇** <br> '스타일봇'은 가상의 모델을 활용하여, 앱 내에 있는 옷을 입혀보거나 실제 옷을 등록하여 가상의 모델에게 입혀볼 수 있는 서비스입니다. 실제로 옷을 구매하기 전, 색상에 따른 매칭을 진행해볼 수 있다는 점과, 기온에 맞춘 코디 추천 기능이 장점입니다. 다만, 앱 내에 있는 옷이 아닌, 실제 옷을 등록할 때 엄격한 가이드에 맞춰 직접 촬영해야하는 불편함이 있습니다.<br> **3. 이옷** <br> '이옷'은 사용자가 입력한 나이, 체형을 기반으로 AI 스타일리스트가 코디를 제안하는 서비스입니다. 이옷은, 상품 진열이 아닌, 하나의 코디를 제안하는 어플이기 때문에, 사용자가 옷을 고민할 필요가 없습니다. 또한 이옷 내에서 엄선한 브랜드의 제품을 추천하는 서비스가 있어, 사용자가 브랜드마다 카테고리를 정해서 볼 수 있다는 장점이 있습니다. 다만, 사용자가 선호하는 컬러를 한가지만 선택할 수 있어, 사용자가 아쉬워하는 케이스가 많았습니다. <br> '코콘'과 비교했을 때, 저희 앱에서 코디해주는 옷은 사용자와 유사한 체형의 세터가 추천해주는 옷이기에 키와 몸무게가 고려된 옷입니다. 따라서, 시커는 실제로 옷을 구매할 확률이 높아질 수 있습니다. 또한, 날씨와 장소도 함께 고려하기 때문에 실제로 코디를 활용할 가능성이 높습니다. '스타일봇'과 비교했을 때, 실제 사용자의 체형과 유사한 세터가 추천해주는 옷이기 때문에, 가상의 모델을 사용하는 것과 비교했을 때, 실제 사용자가 입었을 때 어떨지 예상하기가 쉽다는 것입니다. 세터가 사진을 보내줄 수도 있고, 부가적인 설명을 통해서 옷에 대한 정보를 파악하기가 유리합니다.'이옷'과 비교했을 때, 체형 정보를 더 자세히 기입할 수 있어 더 개인화된 코디를 추천받을 수 있다는 장점이 있습니다. <br> 기존의 서비스들과 비교했을 때, 저희 앱의 가장 큰 차별점은 기존의 모든 앱들은 AI로 추천을 해주는 반면 저희 앱의 경우, 사람이 직접 코디를 해주는 앱이라는 것입니다. 이를 통해, 조금 더 현실적인 코디 조언 및 개인화 된 코디 조언을 받을 수 있다는 것이 장점입니다. |
| (3) 제안 내용 | 저희 앱은 “시커”와 “세터”의 개념을 도입하여 seeker를 코디에 대한 조언을 얻길 원하는 사용자로, setter를 다른 사람에게 코디 조언을 주는 사용자로 정의하였습니다. 저희팀은 체형 및 스타일에 맞는 코디 추천을 원하는 seeker에게, 맞춤형 setter가, 리뷰 사진 및 모델 사진을 분석하는 AI 모델을 활용하여 최적의 아이템을 선별해 코디 조언을 해주도록 할 것입니다. 이때, AI 모델은 리뷰 사진을 분석하여 가장 많이 매칭된 아이템을 선별합니다. 저희는 기존의 사용 방법이 복잡하고, AI 추천이기에 개인화되지 않았던 코디를 개선한 앱을 제안했습니다. |
| (4) 기대효과 및 의의 | **Seeker**<br> Seeker은 사용자 맞춤형 코디 추천을 통해 기존의 옷을 효과적으로 활용할 수 있고, 자신의 스타일을 쉽게 찾을 수 있습니다.<br> **Setter** <br>Setter의 경우, 경험이 부족한 패션 루키들에게 실질적인 스타일링 경험을 제공하고, 자신만의 포트폴리오를 쌓을 기회를 제공한다는 것입니다.또한, AI를 활용해 시간과 물리적 한계를 극복하고 setter가 다수의 사용자에게 빠른 코디 추천을 제공하도록 합니다. 이를 통해, 최종적으로는 의류 소비를 줄여 의류 폐기물 문제를 해소하고자 합니다. |
| (5) 주요기능리스트 | **기능 1. 회원 가입** <br> 회원가입 기능은 사용자가 앱에 처음 접근할 때 필요한 정보를 입력하고, Seeker와 Setter로 구분하여 가입을 진행하는 기능입니다. 입력된 정보는 이후 스타일 분석 및 스타일링 조언을 위한 기초 데이터로 사용됩니다. 주요 구성 요소는 사용자 역할 선택, 기본 정보 입력, 신체 정보, 스타일 선호도 선택 등이 포함됩니다. <br> **기능 2. 추천 스타일 생성** <br> 추천 스타일 생성 기능은 사용자가 선택한 스타일 사진을 분석하여 맞춤형 스타일을 생성하는 기능입니다. 다양한 스타일 사진 데이터셋을 수집하고 사전 처리를 거쳐 사용자의 스타일 취향에 맞춘 스타일을 자동으로 추천합니다. 이를 통해 Seeker에게 개별화된 스타일을 제공합니다.<br> **기능 3. 사용자(Seeker) 스타일 분석**<br> 사용자의 선호 스타일 사진을 분석하여 Seeker의 스타일 프로파일을 생성하는 기능입니다. 시커가 선호하는 스타일 요소(색상, 패턴, 질감 등)를 추출해 스타일 프로파일을 체계적으로 정의하고, 이후 세터가 이를 참고할 수 있도록 지원합니다. 이 프로필은 데이터베이스에 저장됩니다.<br> **기능 4. AI 기반 코디 추천** <br> AI를 통해 Seeker의 스타일에 맞는 코디를 추천하는 기능입니다. 객체 탐지 모델을 활용해 사용자가 선택한 옷과 자주 매칭된 아이템을 분석하고 추천합니다. 데이터베이스에 저장된 빈도 정보를 바탕으로 가장 매칭이 잘 되는 옷을 추천하여 사용자 경험을 향상시킵니다. <br> **기능 5. 일대일 코디 추천**<br>유사한 체형과 스타일을 가진 Seeker와 Setter를 매칭하여 일대일 코디 추천을 제공하는 기능입니다. 사용자 간 매칭을 통해 스타일링 팁과 코디를 공유하며, 개인화된 소셜 경험을 제공합니다. AI 인터페이스를 통해 매칭과 추천 과정을 효율적으로 구현합니다.


<br>
 
# Project-Design & Implementation
| 항목 | 내용 |
|:---  |---  |
| (1) 요구사항 정의 | <br> <br>  **Use Case Diagram** <br> ![use case diagram](https://github.com/user-attachments/assets/24752f95-297d-480c-8fb9-6dce025288ed) <br>  **Class Diagram** <br> ![image](https://github.com/user-attachments/assets/7338f176-3bd1-4da9-894c-9e83aca40376) <br> **UI 분석/설계 모델** <br>![image](https://github.com/user-attachments/assets/8411c489-26b5-4528-873f-ae1437ef3313) <br>figma 주소:https://www.figma.com/proto/1js7KTynyhA60sL29Ux14b/%EC%BA%A1%EC%8A%A4%ED%86%A4-240512?node-id=0-1&t=m0DUhclfnZQjY5NZ-1 <br> **ER 다이어그램** <br>![er diagram drawio](https://github.com/user-attachments/assets/91fb835f-86c9-4273-afb6-db45dfa03318) <br> **DB 설계 모델(테이블 구조)** <br><img width="863" alt="ㅅ" src="https://github.com/user-attachments/assets/64d09fbf-da75-4741-a272-352eb02b7f57">|
| (2) 전체 시스템 구성 |![ㄷㄹㄹ](https://github.com/user-attachments/assets/82f49309-135c-43f1-8452-16bdf89cab37) <br>**SW 전체 시스템 구조**<br>이 프로젝트는 클라이언트-서버 아키텍처로 구성되어 있으며, 프론트엔드는 React Native와 TypeScript를를 사용하고, 백엔드는 Django 기반의 프레임워크로 구축되었습니다. 데이터베이스는 PostgreSQL을 사용하며, 서버는 AWS EC2에서 호스팅되고 있습니다. 사용자는 웹 브라우저를 통해 서비스에 접속하고, 로그인 후 데이터를 입력할 수 있습니다. 서버는 데이터를 처리하고, 데이터베이스에 저장한 후, 필요한 경우 외부 API와 연동하여 추가 정보를 가져옵니다. <br><br> **주요 동작** <br> 1. 사용자 요청 <br> 시커와 세터는 모바일 애플리케이션 (React Native와 TypeScript 기반)을 통해 클라이언트로 접속하고 서버로 스타일 정보 요청을 보냅니다. 클라이언트는 Axios 등을 사용하여 서버와 통신합니다 <br> 2.  요청서, 제안서 작성 및 전송<br>시커는 자신의 스타일링 요청서를 작성하여 서버로 전송합니다.서버는 요청서를 수신하면서 고유 식별자 (Request ID)를 생성하여 요청서에 부여하고, 이 요청서를 데이터베이스에 저장합니다. 서버는 요청서의 고유식별자를 기반으로 해당 요청서를 특정 세터에게만 할당하고, 세터는 자신의 클라이언트 애플리케이션에서 이 요청서를 조회할 수 있습니다. 이때, 서버는 세터에게 요청서를 확인할 수 있도록 알림을 보냅니다. 세터는 시커의 요청서를 확인한 후, 요청에 부응하는 스타일링 제안서를 작성하여 서버로 전송합니다. 제안서에는 해당 요청서의 고유식별자가 포함되어 , 서버가 이 제안서가 특정 요청서에 대한 응답임을 식별할 수 있게 합니다. 서버는 이 식별자를 기반으로 제안서를 요청서를 작성한 해당 시커에게만 전송하여, 시커가 이 제안서를 확인할 수 있도록 합니다. 세터는 서버에서 시커의 요청서를 수신하고 내용을 확인한 후, 요청에 부응하는 스타일링 제안서를 작성하여 서버로 전송합니다. 서버는 세터가 작성한 제안서를 데이터베이스에 저장하고, 시커가 이를 확인 할 수 있도록 처리합니다.<br>3. 요청 수신 및 라우팅<br>Nginx 웹 서버가 클라이언트 요청을 수신하고, 이를 uWSGI를 통해 Django 애플리케이션으로 전달합니다. Nginx는 요청을 로드 밸런싱하며, 클라이언트의 데이터를 안전하게 전달합니다.<br>4. 서버 처리 및 데이터 연동 <br>Django는 클라이언트의 요청을 처리하고, 필요한 데이터가 있을 경우 PostgreSQL 데이터베이스와 AWS S3에 저장된 파일을 참조합니다. 이과정에서 데이터베이스와의 쿼리 작업을 수행하고, 필요한 경우 파일 데이터도 가져와 클라이언트에게 전달합니다.<br>5. CI/CD 자동화<br>개발자는 GitHub를 통해 코드를 관리하며, 변경이 발생하면 GitHub Actions가 자동으로 CI/CD 파이프라인을 수행하여 AWS EC2 서버에 최신 버전이 배포됩니다. 이를 통해 시스템의 일관성과 신속한 배포를 유지할 수 있습니다. <br><br>**주요 SW 모듈 및 역할**<br>- React Native,TypeScript: 프론트엔드 기술 스택으로 사용자 인터페이스를 관리하며, 사용자의 입력을 받아 서버로 전달하고, 서버에서 받은 데이터를 화면에 보여줍니다. 즉, 시커와 세터가 서버와 상호작용할 수 있도록 지원합니다.<br>- 요청서 관리 모듈 (Django): 시커가 작성한 스타일링 요청서와 세터가 작성한 스타일링 제안서를 생성, 저장, 조회, 수정하는 모듈입니다. 이 모듈은 요청서 및 제안서의 1:1 전송 및 매칭을 관리하며 , 요청서에 할당된 고유 식별자를 통해 특정 요청서와 제안서를 서로 연결합니다.<br>- API 관리 모듈(python): 서버와 클라이언트 간의 데이터 요청과 응답을 처리하며, 외부 API와 통신하여 필요한 데이터를 가져옵니다.<br>- 데이터베이스 모듈(PostgreSQL): 사용자 데이터를 저장하고, 쿼리를 통해 필요한 데이터를 제공합니다.<br>- 사진 데이터베이스(AWS S3 socket) : 이미지나 파일 데이터 등을 저장하는 공간으로 로컬에 저장되어있지 않은 파일을 서버가 필요로 할 때 AWS S3에서 가져와 제공할 수 있습니다.<br>-Docker: Nginx, uWSGI, Django 애플리케이션을 각각 컨테이너로 실행하여 일관된 환경에서 애플리케이션을 운영할 수 있게 합니다.<br><br>**오픈소스 및 외부 모듈**<br>- React Native : 사용자 인터페이스(UI)를 구현하는 데 사용한 오픈소스 라이브러리입니다.<br>- Django : 서버 측에서 HTTP 요청을 처리하는 백엔드 프레임워크입니다.<br>- PostgreSQL : 데이터베이스 관리 시스템으로, 프로젝트의 모든 데이터를 저장하고 쿼리를 처리합니다.<br>- Cloth Segmentation : https://github.com/levindabhi/cloth-segmentation <br>- ML Learning Algorithm : https://github.com/Sapphirine/Clothes-Matching-Based-on-Machine-Learning-Algorithms <br>- 모델 생성 및 학습(Mask R-CNN) : Mask R-CNN을 통해 분류된 의류를 기반으로, 머신러닝 알고리즘을 사용하여 가장 많이 매칭된 옷과 모델샷에 사용된 옷을 분석해 줍니다.<br> - 정적 타입 시스템(TypeScript): JavaScript의 안정성 및 객체 지향 프로그래밍을 위해 사용하는 라이브러리입니다. <br><br>**데이터 흐름 설명** <br>1. 클라이언트 -> 서버 <br>클라이언트가 React Native와 TypeScript로 구성된 프론트엔드에서 Axios등을 통해 요청을 전송합니다. 예를 들어 시커가 스타일 추천을 요청하거나 스타일링 요청서를 작성하여 서버로 전송하는 경우, 서버는 요청서에 고유 식별자를 부여하고 이를 데이터 베이스에 저장합니다.<br>2. Ngnix -> uWSGI -> Django<br>Ngnix가 요청을 수신하고, uWSGI를 통해 Django 애플리케이션 서버로 전달하여 비즈니스 로직을 수행합니다. Django는 API 요청에 따라 데이터베이스 및 파일 저장소와 상호작용합니다. <br> 3. Django <-> PostgreSQL ,AWS S3 <br> Django는 PostgreSQL, 데이터베이스와 통신하여 시커와 세터의 프로필, 추천 스타일 정보 등을 조회하거나 업데이트 합니다. 이미지나 파일 데이터가 필요한 경우 AWS S3에서 가져옵니다.<br>4. 서버 -> 클라이언트 응답<br>Django에서 처리된 결과는 JSON응답 형태로 변환되어 클라이언트에 반환됩니다. 예를들어 , 서버는 세터가 작성한 제안서를 요청서의 고유 식별자를 통해 특정 시커에게만 전송합니다. 클라이언트는 응답데이터를 화면에 표시하여 시커와 세터가 결과를 확인 할 수 있도록 합니다. |
| (3) 주요엔진 및 기능 설계 | <br>**스타일 학습 모듈**<br><br>스타일 학습 모듈은 기존의 AI 추천 방식에서 발생하는, 사용자 개인의 선호를 제대로 반영하지 못하는 문제를 해결하기 위해 설계된 주요 모듈입니다. 이 모듈은 사용자의 취향을 면밀히 분석하여, 시커와 세터 간의 최적의 매칭을 제공함으로써 개인화된 코디 경험을 제공합니다. 또한, 사용자 개별 프로파일을 통해 맞춤형 매칭이 이루어지도록 지원하여, 만족도 높은 코디 경험을 제공하며, 세터에게는 자신의 스타일을 활용할 수 있는 의미 있는 스타일링 기회를 제공합니다.<br>•    사용자가 자신의 선호 스타일을 나타내는 사진을 선택하면, AI 모델이 각 사진에서 옷의 색상, 패턴, 형태와 같은 주요 스타일 요소를 추출하여 분석합니다.<br>•    이렇게 분석된 정보를 통해 사용자의 스타일 취향을 학습하게 되며, 이를 기반으로 한 스타일 프로파일이 구축됩니다. 스타일 프로파일은 개인의 선호를 반영하며, 이후 시커와 세터 간의 매칭에 활용됩니다.<br>•    이 모듈은 시커가 새로운 스타일을 선호할 경우 또는 사용자의 취향이 변할 때마다 프로파일을 자동으로 갱신하여, 동적인 사용자 선호를 반영하도록 설계되어 있습니다. 이를 통해 한층 정교하고 개인화된 매칭이 가능해집니다. <br>**구현 방법:** <br>•    스타일 요소 추출 AI 모델: 사진 내 주요 스타일 요소를 추출하는 AI 모델을 구축합니다. 색상, 패턴, 형태 등을 효과적으로 인식할 수 있는 알고리즘을 사용하여, 사용자 이미지에서 스타일을 식별하고 이를 벡터화하여 저장합니다.<br>•    개인화된 스타일 프로파일 생성 및 저장: 사용자가 선택한 이미지에서 추출된 스타일 요소를 바탕으로 사용자 개별 프로파일을 생성하고 저장합니다. 이 프로파일은 사용자의 선호와 일관된 코디를 제공하는 데 활용되며, 변화하는 취향에 맞춰 유연하게 갱신됩니다.<br>•    실시간 갱신 기능: 사용자가 새로운 스타일 사진을 선택하거나, 기존 선호가 변화할 때마다 프로파일이 실시간으로 업데이트됩니다. 이를 통해 스타일 추천이 고정되지 않고, 변화하는 사용자 취향에 따라 더욱 적합한 매칭이 이루어지도록 합니다.<br>**알고리즘:** <br>•    StyleGAN 활용: 스타일 학습 모듈은 StyleGAN과 같은 생성적 적대 신경망(GAN)을 기반으로 구현됩니다. StyleGAN은 선택된 이미지에서 스타일 요소를 벡터화하여 사용자의 스타일을 학습합니다. 이렇게 벡터화된 요소를 기반으로 유사 스타일을 분석하여 매칭 가능성을 평가합니다.<br>•    스타일 유사성 평가 및 매칭: StyleGAN을 통해 사용자가 선택한 스타일과 유사한 스타일을 학습하고, 유사도를 평가하여 세터와 시커를 매칭합니다. 세터와 시커 간 매칭을 통해 양측 모두가 만족할 수 있는 코디 경험을 제공합니다.<br>•    유사도 기반 추천: StyleGAN이 벡터화한 스타일 요소는 유사도 계산에 활용되며, 이를 통해 사용자의 취향과 가장 근접한 스타일을 보유한 세터가 추천됩니다. 세터는 추천된 스타일을 바탕으로 코디를 제안하며, 시커에게 맞춤형 스타일링을 제공합니다.<br><br>**AI 기반 코디 추천 모듈**<br><br>AI 기반 코디 추천 모듈은 시커가 요청한 스타일에 맞춰 최적의 코디를 제공하기 위한 핵심 기능으로, 요청서에 포함된 아이템과 가장 잘 매칭된 스타일을 AI 분석을 통해 선별합니다. 이를 통해 시커는 요청한 스타일에 맞는 최적의 코디를 추천받을 수 있으며, 세터에게는 스타일링 경험을 쌓고 코디 제안을 제시할 수 있는 기회를 제공합니다.<br>•    데이터 수집 및 전처리: AI 추천의 첫 단계로, 다양한 패션 이미지를 수집하여 체형, 스타일, 의류 종류에 맞춰 정제된 데이터셋을 구성합니다. 이를 위해 크롤링 기술을 통해 패션 사이트에서 이미지를 수집하고, 필요에 따라 라벨링을 추가하여 분석에 최적화된 고품질 데이터를 확보합니다.<br>•    객체 탐지 및 라벨링: YOLO나 Faster R-CNN과 같은 객체 탐지 모델을 사용하여 각 이미지 내에 포함된 의류 아이템을 식별하고 라벨링합니다. 각 의류 아이템의 종류와 빈도는 데이터베이스에 기록되며, 향후 요청서에 포함된 아이템과 유사한 스타일을 추천하는 데 사용됩니다.<br>•    스타일 매칭 및 빈도 기반 추천: DB에 저장된 의류 아이템과 스타일 빈도 정보를 활용하여 시커가 요청한 아이템과 가장 많이 매칭된 스타일을 분석하고 추천합니다. 예를 들어, 특정 재킷이 요청서에 포함된 경우, DB에서 해당 재킷과 자주 매칭된 다른 의류 및 스타일을 추출하여 세터에게 추천 목록으로 제공합니다.<br>**구현 방법:** <br>•    객체 탐지 모델 구축 및 데이터 라벨링: 공개된 패션 데이터셋이나 커스텀 데이터셋을 활용하여 학습된 객체 탐지 모델을 사용하여 사진에서 의류 아이템을 식별합니다. 이후 각 아이템에 라벨을 부여하고, 분석에 필요한 주요 특징이 잘 드러나는 고품질 이미지만을 선별하여 저장합니다.<br>•    유사도 기반 스타일 매칭 알고리즘: 스타일 매칭을 위해 Nearest Neighbor 알고리즘을 사용하여 시커의 요청 아이템과 유사한 스타일을 우선적으로 추천할 수 있도록 설정합니다. 유사도 계산은 의류 아이템의 색상, 패턴, 형태 등의 특징을 벡터화하여 이루어지며, 이를 통해 사용자의 요청 스타일과 가장 일치하는 코디를 찾아낼 수 있습니다.<br>•    세터 추천 목록 생성 및 제안서 작성: 분석된 추천 목록을 바탕으로, 세터는 자신의 스타일과 시커의 요청서에 부합하는 최적의 코디를 선택하여 시커에게 제안서를 작성해 전달합니다.<br>**알고리즘:** <br>•    유사도 기반 추천: 이 모듈은 각 의류 아이템의 주요 스타일 요소를 벡터화하고, 시커의 요청 아이템과 유사한 스타일을 우선적으로 추천할 수 있도록 설정됩니다. 이를 통해 스타일 요소 간 유사성을 계산하여 시커의 선호에 가까운 세터를 찾아 매칭합니다.<br>•    빈도 기반 추천: 데이터베이스에 저장된 각 의류 아이템의 등장 빈도 정보를 바탕으로, 특정 의류와 자주 매칭되는 다른 스타일을 추천합니다. 예를 들어, 특정 재킷이 다른 의류와 자주 매칭된 경우 이를 세터에게 우선 추천하여, 세터는 요청서에 맞는 최적의 코디를 제안할 수 있습니다.<br>•    추천 목록 기반 코디 제안: AI 모델이 생성한 추천 목록에서 세터는 시커의 요청 조건을 고려하여 최적의 코디를 선정하고, 이 코디를 기반으로 제안서를 작성하여 시커에게 전달합니다. <br><br>**사용자 피드백 반영 모듈**<br><br> 사용자 피드백 반영 모듈은 사용자의 피드백을 실시간으로 반영하여 추천 시스템의 정확도를 지속적으로 향상시키기 위한 주요 모듈입니다. 이 모듈은 사용자가 제공한 선택 정보를 학습하여, 개인화된 스타일 추천을 지속적으로 업데이트함으로써 사용자 경험을 최적화합니다. 피드백 데이터를 기반으로 사용자 선호도를 학습하고 예측하여, 맞춤형 추천을 강화하는 것이 이 모듈의 핵심 목표입니다.<br>•    선호도 학습 및 개인화 프로필 반영: 사용자가 선택한 아이템에 대한 빈도를 학습하여, 색상, 패턴, 스타일 요소와 같은 속성에 대한 사용자의 선호도를 반영합니다. 이를 통해 사용자 맞춤형 개인화 프로필을 생성하고, 사용자가 선호하는 스타일을 기반으로 더욱 정확한 추천을 제공합니다.<br>•    반복 선택 패턴 학습: 사용자가 반복적으로 선택한 스타일 요소를 분석하고 학습하여, 추천 시스템이 사용자의 취향을 지속적으로 반영할 수 있도록 지원합니다.<br>•    실시간 피드백 반영: 새로운 피드백이 제공될 때마다 이를 즉시 반영하여, 추천의 적합성을 높이기 위해 개인화 프로필을 업데이트합니다.<br>**구현 방법:** <br>•    피드백 데이터 수집 및 전처리: 사용자가 코디에 대해 제공한 피드백 데이터를 수집하고 전처리하여, 사용자의 선호를 분석합니다. 특히, 사용자가 긍정적으로 평가한 아이템의 속성과 반복적으로 선택한 패턴을 집중적으로 학습합니다.<br>•    개인화 프로필 생성: 피드백 데이터를 바탕으로 사용자의 스타일 속성(색상, 패턴, 형태 등)을 반영한 개인화 프로필을 생성합니다. 이 프로필은 추천의 정확도를 높이기 위해 사용자의 선호에 따라 지속적으로 갱신됩니다.<br>•    딥러닝 모델을 활용한 선호도 예측: 사용자 피드백 데이터를 학습하여 사용자의 선호도를 예측하는 알고리즘을 구현합니다. 이를 위해 *Recurrent Neural Network (RNN)*와 Long Short-Term Memory (LSTM) 모델을 활용합니다. RNN과 LSTM은 반복적인 데이터 학습에 효과적이며, 사용자의 반복적인 선택 패턴을 학습하여 개인화된 추천을 제공합니다.<br>•    협업 필터링: 피드백 기반 추천을 위해 사용자들 간의 유사도를 고려하여 추천 품질을 높이는 협업 필터링 기법을 적용합니다. 사용자의 피드백 데이터를 분석하여 유사한 선호도를 가진 사용자 그룹을 생성하고, 이를 기반으로 추천 정확도를 높입니다.<br>**알고리즘:** <br>•    RNN 및 LSTM 모델을 활용한 선호도 학습: 사용자가 반복적으로 선택하는 스타일 요소를 학습하기 위해 Recurrent Neural Network (RNN) 및 Long Short-Term Memory (LSTM) 네트워크를 사용합니다. 이 알고리즘은 시계열 데이터에서의 패턴 학습에 강점이 있어, 사용자의 반복적인 선택 및 선호 패턴을 예측하는 데 적합합니다. RNN과 LSTM은 사용자가 과거에 선호한 스타일 요소들을 학습하여, 유사한 속성을 가진 아이템을 추천할 수 있도록 합니다.<br>•    협업 필터링 기반 추천: 사용자의 피드백 데이터에 기반하여 유사한 선호를 가진 다른 사용자들과의 데이터를 비교하는 협업 필터링 기법을 사용합니다. 이를 통해, 사용자가 선호할 가능성이 높은 아이템을 추천 리스트에 포함시킵니다.<br>•    피드백 기반 실시간 갱신: 사용자가 피드백을 제공할 때마다 즉시 이를 분석하여 개인화 프로필을 갱신하고, 선호도에 따른 추천 리스트를 실시간으로 조정합니다. LSTM 네트워크는 장기 기억을 활용하여 사용자 패턴 변화를 반영하고, 협업 필터링은 유사 사용자와의 비교를 통해 추천의 다양성을 높입니다.<br>사용자 피드백 반영 모듈은 RNN과 LSTM 알고리즘을 통해 반복적인 선택 패턴을 학습하고, 협업 필터링 기법을 통해 유사 사용자의 선호도를 참고하여 추천의 정확도를 높입니다. 이를 통해 사용자는 보다 개인화된 스타일 추천을 받을 수 있으며, 시시각각 변화하는 선호도에 맞춘 맞춤형 코디를 경험할 수 있습니다.|
| (4) 주요 기능의 구현 | <br><br>**기능 1. 회원 가입**<br><br>회원가입 기능은 사용자가 처음 앱에 접근할 때, 필요한 정보를 입력 받아 ‘Seeker(시커)’와 ‘Setter(세터)’로 구분하여 회원가입을 진행합니다. 사용자가 입력한 신체정보, 스타일 선호도, 체형 정보 등은 이후 스타일 분석 및 스타일링 조언 기능을 지원하기 위해 중요한 기초 데이터로 화룡됩니다.<br>구성요소는 사용자 역할 선택, 기본정보(아이디, 비밀번호 ) 입력, 신체 정보 (키, 몸무게, 체형 ), 스타일 선호도 선택 등이 있습니다.<br>***회원 가입 및 사용자 정보 입력 모듈***<br>회원가입 및 사용자 정보 입력 모듈은 회원가입 화면에서 사용자가 입력한 다양한 데이터를 수집하고, 이를 정리하여 데이터베이스에 저장하는 역할을 수행합니다. 사용자는 Seeker와 Setter 중 자신의 역할을 선택하며, 이 정보는 모듈에 저장되어 이후 Seeker와 Setter에게 맞는 기능과 UI 가 제공될 수 있도록 설정됩니다. 이어서 Seeker, Setter 각각 회원 가입 화면에서는 아이디, 비밀번호 등의 기본정보와 키, 몸무게 등 신체정보를 입력합니다. 이 정보는 Seeker의 경우 스타일 프로필 생성에, Setter의 경우 Seeker의 신체 특성에 맞춘 스타일링을 제공하는데 참고됩니다. 또한 사용자가 회원 가입 과정에서 선택하는 선호 스타일( 미니멀, 빈티지, 캐주얼 등)과 체형정보 (사각형, 역삼각형 등)도 이 모듈에 의해 수집되어 저장됩니다. 이 정보들은 Seeker의 경우 스타일 프로필 생성에, Setter의 경우 Seeker의 신체 특성에 맞춘 스타일링을 제공하는데 참고됩니다.<br>회원가입 및 사용자 정보 입력 모듈에 의해 수집된 정보는 스타일 프로필 생성 모듈로 전달됩니다. 스타일 프로필 생성 모듈은 이 정보를 기반으로 Seeker 스타일 프로필을 생성하여 데이터 베이스로 저장합니다. 이 프로필은 이후 스타일 추천 및 도우미 기능의 추천 스타일 생성 모듈에서 에서 참고자료로 사용됩니다.<br><br>**기능 2. ‘seeker’ 회원가입** <br><br>***추천 스타일 생성 모듈***<br>- 설명 : 이 모듈은 사용자가 선택한 사진들을 분석하여 맞춤형 스타일을 생성한다. 각 사용자의 사진 선택을 반영해 자동으로 스타일을 추천한다.<br>- 구현 방법 : 스타일 추천에 사용할 다양한 사진 데이터셋을 수집하고, 각 사진에 스타일 유형, 색상, 패턴, 텍스쳐등 스타일에 대한 정보를 라벨링한다. 그 이후, 이미지 크기를 조정하고 정규화하는 것과 같은 사전 처리를 진행한다. 이후 기존에 오픈되어있는 알고리즘 소스를 활용하여 스타일을 분석한다.<br><br>**기능 3. 사용자(시커) 스타일 분석**<br><br>스타일 분석 기능은 시커가 회원가입 시 자신의 선호 스타일 사진을 선택하면, 이를 바탕으로 스타일 요소(색상, 패턴, 질감 등)를 분석하여 시커의 스타일 프로파일을 생성합니다. 이 기능은 시커의 스타일 취향을 파악하고, 이후 세터가 스타일 도우미 기능을 사용할 때 참고할 수 있도록 시커의 스타일을 체계적으로 정의하는 역할을 합니다.<br>***이미지 처리 및 스타일 분석 모듈***<br>시커가 선택한 스타일 사진에서 색상, 패턴, 질감 등의 주요 스타일 요소를 추출합니다. 이를 통해 시커의 스타일을 세부적으로 파악합니다. 이 모듈은 시커의 스타일을 분석하는 과정에서 중요한 역할을 하며, 스타일 프로필 생성 모듈에 스타일 요소 데이터를 전달합니다. <br>***스타일 프로필 생성 모듈***<br>이미지 처리 및 스타일 분석 모듈에서 전달 받은 스타일 데이터를 기반으로, 시커의 스타일 프로필을 생성하고 저장합니다. 이 프로필은 시커의 스타일 취향을 체계적으로 정의하며, 이후 세터가 시커의 스타일을 이해하고 참고할 수 있는 기초 자료로 사용됩니다.이 모듈은 시커의 스타일 요소 데이터를 종합하여, 스타일 프로필을 생성하며, 생성된 프로필은 이후 세터가 참고 할 수 있도록 데이터 베이스에 저장됩니다. 이 기능은 시커가 회원 가입을 통해 스타일 사진을 선택할 때 실행됩니다. <br><br> **기능 4. AI 기반 코디 추천 기능** <br><br>코디 추천 시 함께 자주 매칭한 옷과 쇼핑몰 옷 사진에서 함께 매칭한 옷 사진을 볼 수 있도록 하는 기능이다.<br> ***AI 기반 코디 추천 모듈***<br>-설명  : 이전에 분석해둔 DB를 통해, 사용자가 선택한 옷에 대해서 매칭이 많이 된 옷과 모델샷에서 같이 매치된 옷을 추천하는 모듈이다.<br>- 구현 방법 : 각 사진에 등장하는 옷을 객체 탐지 모델을 활용하여 라벨링을 한 후, 유사한 사진이나 중복된 이미지를 제거하고, 분석에 필요한 주요 특징이 잘 드러나는 고품질 이미지를 선별한다. 시중에 공개되어있는 객체 탐지 모델을 활용하여 사진에서 의류 아이템을 식별한 후, 각 아이템의 종류를 DB에 저장한다. 이때, 사진 한장에 나타난 의류 아이템들을 함께 나타난 수에 따라 기록한다. 이를 DB에 빈도 정보로 저장하여 추천하는데 사용하게 된다.<br>***사용자 피드백 반영 모듈***<br>-설명: 사용자의 선택을 분석하고 반영해 추천 시스템의 성능을 개선하는 모듈입니다. 사용자의 선호도를 지속적으로 학습해 추천의 정확도를 높이며, 사용자 경험을 최적화합니다.<br>-구현 방법: 사용자가 선택한 옷에 대한 선택 빈도를 분석한다. 이를 통해, 선호도를 파악하는 개인화 프로필을 생성한다. 이 프로필은, 색상, 패턴 등 여러 속성에 대한 사용자의 취향을 반영하게 된다. 시중에 공개되어있는 피드백 데이터를 기반으로 딥러닝 모델을 학습하여 사용자의 선호도를 예상하는 알고리즘을 사용하여 사용자의 선호도를 예측하는 알고리즘을 구현한다. 특히, 반복적인 선택 패턴을 학습하여, 추천의 정확도를 높일 수 있다.<br><br>**기능 5. 일대일 코디 추천 기능**<br><br>***매칭 알고리즘 모듈***<br>- 설명: 사용자 간 매칭을 통해 스타일링 팁, 코디 공유 등 소셜 기능을 제공하는 모듈입니다. 유사한 체형과 스타일을 가진 사용자들을 연결해 주고, 코디를 추천할 수 있도록 합니다.<br>- 구현 방법: 같은 체형과 스타일을 가진 ‘세터’와 ‘시커’가 있다면 매칭해주는 방식으로 진행한다. |
| (5) 진척도 및 검증내역 |<br>**스타트 단계에서의 기술 구현** <br>- Back-End : 매칭 알고리즘 부분 구현 및 회원가입 구현<br>- Front-End : 진행X<br> - AI part : 데이터셋 학습 및 데이터 크롤링 <br>**그로쓰 현진행 상황** <br>- Back-End : 60% 구현 완료 <br>- Front-End : 100% 구현 완료<br> - AI part : 80% 구현 완료 <br> 향후 백엔드와 AI 더 develop할 예정|


<br>
 
# Evaluation
| 항목 | 내용 |
|:---  |---  |
| (1) 평가항목 | <br> <br> 평가 항목으로 시간(Time), F1 스코어(F1 Score), mAP, 그리고 성능 지표를 선정하였습니다. 시간은 모델의 처리 효율성을 나타내며, F1 스코어는 정밀도(Precision)와 재현율(Recall) 간의 조화를 평가합니다. mAP는 모델이 검출한 객체의 평균 정확도를 측정하고, 성능 지표는 가중치를 적용한 종합적인 점수로 성능의 최종적인 판단 기준으로 사용됩니다.<br>   성능 지표는 여러 평가 항목의 균형을 고려하여 최종적으로 최적의 모델을 선택하기 위해 도입되었습니다.<br> 평가 : 성능 지표를 사용하여 평가하며, 시간의 비중은 상대적으로 낮은 가중치를 적용합니다. 아래는 성능 지표의 계산식입니다 : ![이미지 설명](https://github.com/doyoom/capstonefinalreport/blob/main/final1.png?raw=true) 모델 실행 시 동일한 환경에서 시간 데이터를 측정합니다. 모든 모델은 동일한 데이터셋과 조건에서 3회 반복 실행됩니다. 측정된 시간의 평균값을 계산하여 성능 지표 계산에 반영합니다.<br><br> F1 스코어는 정밀도(Precision)와 재현율(Recall) 간의 조화 평균으로, 다음 공식을 통해 계산됩니다:<br> 정밀도(Precision): 모델이 검출한 객체 중 실제로 맞는 비율<br> 재현율(Recall): 실제 객체 중 모델이 검출한 비율:![이미지 설명](https://github.com/doyoom/capstonefinalreport/blob/main/final4.png?raw=true)<br> <br> 이 값은 0에서 1 사이의 범위를 가지며, 1에 가까울수록 정밀도와 재현율 간의 균형이 잘 맞는 모델로 평가됩니다. |<br>
| (2) 평가 1 : <br> 시간(Time) | <br> 설명 : 시간(Time)은 모델이 학습 데이터를 처리하고 결과를 도출하는 데 소요되는 총 시간을 나타냅니다. 단위는 시간(hour)으로 측정하며, 낮을수록 효율적인 모델을 의미합니다. 즉,시간(Time)은 모델이 학습 데이터를 처리하고 결과를 도출하는 데 소요되는 총 시간을 내므로 과제 목표인 실시간 검출 성능과 관련됩니다. 시간 측정값이 낮을수록 효율적인 모델임을 의미합니다.<br><br> 평가기준 : 성능 지표를 사용하여 평가하며, 시간의 비중은 상대적으로 낮은 가중치를 적용합니다.<br> 성능 지표의 계산식은 time *w0 + F1 score * w1 + mAP * w2 이다.<br><br> 평가 방식 : 모델 실행 시 동일한 환경에서 시간 데이터를 측정합니다. 모든 모델은 동일한 데이터셋과 조건에서 3회 반복 실행됩니다. 측정된 시간의 평균값을 계산하여 성능 지표 계산에 반영합니다. |<br>
| (3) 평가 2 : <br> F1 스코어(F1 Score) | <br> 설명 : F1 스코어는 정밀도(Precision)와 재현율(Recall) 간의 조화 평균으로, 검출 정확도를 나타내는 주요 지표 입니다.다음 공식을 통해 계산됩니다: 정밀도(Precision): 모델이 검출한 객체 중 실제로 맞는 비율 / 재현율(Recall): 실제 객체 중 모델이 검출한 비율 / F1 스코어 공식 : 이 값은 0에서 1 사이의 범위를 가지며, 1에 가까울수록 정밀도와 재현율 간의 균형이 잘 맞는 모델로 평가됩니다.<br><br> 평가기준 : 성능 지표 계산식에서 F1 스코어의 가중치가 가장 높게 설정되었습니다. F1 스코어는 검출 성능의 핵심 지표로 간주됩니다.<br><br> 평가 방식 : 테스트 데이터를 기반으로 모델의 정밀도와 재현율을 측정한 후 F1 스코어를 계산합니다. 모든 실험은 동일한 데이터셋에서 수행되며, 측정값은 평균으로 산출하여 성능 지표 계산에 반영됩니다. |<br>
| (4) 평가 3 : <br> C: mAP | <br> 설명 : mAP(mean Average Precision)는 모델이 검출한 객체의 평균 정확도를 나타내며, 다음과 같은 단계로 계산됩니다 : 1.  모든 클래스에 대한 평균 정밀도를 계산합니다. <br> 2. 각 클래스의 평균 정밀도의 합을 전체 클래스 수로 나눕니다. ![이미지 설명](https://github.com/doyoom/capstonefinalreport/blob/main/final5.png?raw=true) <br> mAP는 모델이 다양한 객체를 정확히 검출하는 능력을 평가합니다. ![이미지 설명](https://github.com/doyoom/capstonefinalreport/blob/main/final2.png?raw=true)<br><br> 평가기준 : mAP는 성능 지표 계산식에서 두 번째로 높은 가중치를 부여받았습니다. 이는 모델이 모든 객체를 고르게 검출하는 능력을 중요하게 반영합니다.<br><br> 평가 방식 : 모델이 테스트 데이터를 처리한 결과를 기반으로 mAP를 계산합니다. |<br>
 (5) 평가 4 : <br> 성능지표 | <br> 설명 :성능 지표는 여러 평가 항목의 균형을 고려하여 최종적으로 최적의 모델을 선택하기 위해 도입되었습니다. <br>모든 실험은 동일한 데이터셋으로 수행되며, 각 실험에서 도출된 결과는 평균값으로 계산됩니다.  ![이미지 설명](https://github.com/doyoom/capstonefinalreport/blob/main/final1.png?raw=true) 모델 실행 시 동일한 환경에서 시간 데이터를 측정합니다. 모든 모델은 동일한 데이터셋과 조건에서 3회 반복 실행됩니다. 측정된 시간의 평균값을 계산하여 성능 지표 계산에 반영합니다.<br>|<br>
| (6) 평가내용/결과 | <br> ![이미지 설명](https://github.com/doyoom/capstonefinalreport/blob/main/final3.png?raw=true)<br> 시간(Time)<br>  YOLOv5s (v6.0): 평균 실행 시간은 0.264시간으로 YOLOv5n (v6.0)보다 다소 길었으나, v6.1 버전에서 0.263시간으로 개선되었습니다. YOLOv5n (v6.0 및 v6.1): 평균 실행 시간은 0.260시간으로 가장 짧았습니다. <br> F1 스코어(F1 Score)<br>	YOLOv5s (v6.0): F1 스코어는 0.754로 높은 성능을 보였으며, v6.1에서는 0.733으로 소폭 감소하였으나 여전히 우수한 수준입니다. YOLOv5n (v6.0 및 v6.1): 각각 0.667과 0.706으로 YOLOv5s보다 낮은 결과를 기록했습니다..<br>mAP<br> YOLOv5s (v6.0 및 v6.1): mAP는 각각 0.798과 0.804로 모든 모델 중 가장 높은 성능을 기록했습니다. YOLOv5n (v6.0 및 v6.1): 각각 0.729와 0.704로 YOLOv5s보다 낮은 정확도를 보였습니다.<br> 성능 지표<br> YOLOv5s (v6.0): 성능 지표는 0.665로 가장 높은 점수를 기록했으며, v6.1에서도 0.653으로 여전히 우수한 성능을 유지했습니다. 이는 모든 항목에서 고르게 높은 성능을 보였기 때문입니다.YOLOv5n (v6.0 및 v6.1): 각각 0.598과 0.616으로 YOLOv5s에 비해 낮은 점수를 기록했습니다.<br> 평가는 성능 지표를 사용하며, 시간의 비중은 상대적으로 낮은 가중치를 적용합니다. 아래는 성능 지표의 계산식 입니다. |<br>

# Conclusion<br>
<br> 모든 평가 항목을 종합한 결과, YOLOv5(v6.1) 중 YOLOv5s 모델이 최종적으로 선택되었습니다. 이 모델은 짧은 실행 시간(0.263시간), 높은 F1 스코어(0.733), 그리고 가장 높은 mAP(0.804)를 기록하며, 성능 지표에서도 0.653로 가장 우수한 점수를 나타냈습니다. YOLOv5n 모델은 실행 시간에서 우수한 결과를 보였으나, 검출 성능(F1 스코어와 mAP)에서 상대적으로 낮은 평가를 받았습니다. 향후 YOLOv5s 모델을 기반으로 추가적인 최적화와 실험을 통해 실시간 객체 검출 성능을 더욱 향상 시킬 계획입니다.
